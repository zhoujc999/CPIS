#!/usr/bin/python3

import socket
import sys
import select
import os
import time
from math import pi
from time import sleep
import pidcontroller
from os import path
import numpy as np
import fcntl
from common import read_file, write_file, UPDATE_FREQ
from multiprocessing import Process
import matplotlib.pyplot as plt
from matplotlib.widgets import Slider


SIM_FREQ = UPDATE_FREQ * 2

def motor_torque(omega, params={}):
    # Set up the system parameters
    Tm = params.get('Tm', 190.)             # engine torque constant
    omega_m = params.get('omega_m', 420.)   # peak engine angular speed
    beta = params.get('beta', 0.4)          # peak engine rolloff

    return np.clip(Tm * (1 - beta * (omega/omega_m - 1)**2), 0, None)

def vehicle_update(t, x, u, params={}):
    """Vehicle dynamics for cruise control system.
    
    Modified from https://github.com/python-control/python-control.git

    Parameters
    ----------
    x : array
         System state: car velocity in m/s
    u : array
         System input: [throttle, gear, road_slope], where throttle is
         a float between 0 and 1, gear is an integer between 1 and 5,
         and road_slope is in rad.

    Returns
    -------
    float
        Vehicle acceleration

    """
    from math import copysign, sin
    sign = lambda x: copysign(1, x)         # define the sign() function

    # Set up the system parameters
    m = params.get('m', 1600.)              # vehicle mass, kg
    g = params.get('g', 9.8)                # gravitational constant, m/s^2
    Cr = params.get('Cr', 0.01)             # coefficient of rolling friction
    Cd = params.get('Cd', 0.32)             # drag coefficient
    rho = params.get('rho', 1.3)            # density of air, kg/m^3
    A = params.get('A', 2.4)                # car area, m^2
    alpha = params.get(
        'alpha', [40, 25, 16, 12, 10])      # gear ratio / wheel radius

    # Define variables for vehicle state and inputs
    v = x[0]                           # vehicle velocity
    throttle = np.clip(u[0], 0, 1)     # vehicle throttle
    gear = u[1]                        # vehicle gear
    theta = u[2]                       # road slope

    # Force generated by the engine

    omega = alpha[int(gear)-1] * v      # engine angular speed
    F = alpha[int(gear)-1] * motor_torque(omega, params) * throttle

    # Disturbance forces
    #
    # The disturbance force Fd has three major components: Fg, the forces due
    # to gravity; Fr, the forces due to rolling friction; and Fa, the
    # aerodynamic drag.

    # Letting the slope of the road be \theta (theta), gravity gives the
    # force Fg = m g sin \theta.

    Fg = m * g * sin(theta)

    # A simple model of rolling friction is Fr = m g Cr sgn(v), where Cr is
    # the coefficient of rolling friction and sgn(v) is the sign of v (Â±1) or
    # zero if v = 0.

    Fr  = m * g * Cr * sign(v)

    # The aerodynamic drag is proportional to the square of the speed: Fa =
    # 1/2 \rho Cd A |v| v, where \rho is the density of air, Cd is the
    # shape-dependent aerodynamic drag coefficient, and A is the frontal area
    # of the car.

    Fa = 1/2 * rho * Cd * A * abs(v) * v

    # Final acceleration on the car
    Fd = Fg + Fr + Fa
    dv = (F - Fd) / m

    return dv, omega



def plot_vehicle_status():
    fig, axs = plt.subplots(3, figsize=(8, 4))
    # fig.set_size_inches(18.5, 10.5)
    plt.subplots_adjust(hspace=0.5, top=0.95, bottom=0.05)
    ax = axs[1]
    ax2 = axs[0]
    # ax = fig.gca()
    # ax2 = ax.twiny()
    ax.set_yticks([])
    ax2.set_yticks([])
    ax.set_xlim([0, 140])
    ax2.set_xlim([0, 7500])
    ax.set_xlabel("Speed (KM/H)")
    ax2.set_xlabel("RPM")
    # plt.show()
    cur_spd_rect = ax.barh(0.05, 1, color = 'cyan', height = 0.25, edgecolor='none')
    # set_spd_rect = ax.barh(0.25, 1, color = 'b', height = 0.05, edgecolor='none')
    rpm_rect = ax2.barh(0.6, 1, color = 'tomato', height = 0.25, edgecolor='none')

    axamp = axs[2]
    samp = Slider(axamp, 'Set Spd', 0.0, 140.0, valinit=0)
    gear_label = plt.text(70, 3.3, "  " ,ha='center', va='center', size='x-large', weight='bold')
    while(1):
        set_spd = int(samp.val)
        write_file("set_speed.txt", set_spd)
        cur_spd_rect.patches[0].set_width(read_file('cur_speed.txt', float))
        rpm_rect.patches[0].set_width(read_file('rpm.txt', float))
        gear_label.set_text("Gear %d" % read_file('gear.txt', int))
        plt.pause(0.2)

cur_speed_ms = 0.0
throttle = 0.0
gear = 1
rpm = 0

# Init file
with open('throttle.txt', 'w') as f:
    f.write("0.0")
with open('gear.txt', 'w') as f:
    f.write("1")
with open('cur_speed.txt', 'w') as f:
    f.write("0")
with open('rpm.txt', 'w') as f:
    f.write("0")
with open('slope.txt', 'w') as f:
    f.write("0")

p = Process(target=plot_vehicle_status)
p.start()

while True:
    # Read from engine controller
    throttle = read_file('throttle.txt', float)
    gear = read_file('gear.txt', int)
    slope_deg = read_file('slope.txt', float)
    slope = slope_deg * pi / 180.0

    if os.path.exists("override_speed.txt"):
        cur_speed_ms = read_file("override_speed.txt", float)

    # Vehicle simulation
    if not (cur_speed_ms == 0 and throttle == 0):
        dv, omega = vehicle_update(0, [cur_speed_ms], [throttle, gear, slope])
        cur_speed_ms = cur_speed_ms + (dv / SIM_FREQ)
        rpm = int(omega / ((2*pi)/60))

    print("Speed %.2f KMH, rpm %d" % (cur_speed_ms * 3.6, rpm))
    write_file('cur_speed.txt', cur_speed_ms * 3.6)
    write_file('rpm.txt', rpm)

    time.sleep(1.0 / SIM_FREQ)

print("Now Exit")
p.join()
